<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bird Hunter AR</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #input_video { display: none; }
        #output_canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            transform: scaleX(-1); /* Mirror view */
            z-index: 1;
        }
        #ui_layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
        }
        #score_board {
            color: #FFD700; font-size: 24px; font-weight: bold; padding: 20px;
            text-shadow: 2px 2px 4px #000;
        }
        #guide {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            text-align: center; color: white; font-size: 16px;
            text-shadow: 1px 1px 2px black;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 18px; z-index: 10;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">‡¶¨‡¶®‡ßç‡¶¶‡ßÅ‡¶ï ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá... (Wait for Camera)</div>
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <div id="ui_layer">
        <div id="score_board">Score: 0</div>
        <div id="guide">üñêÔ∏è ‡¶¨‡¶®‡ßç‡¶¶‡ßÅ‡¶ï ‡¶§‡¶æ‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶® | üëå ‡¶∂‡ßÅ‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶Æ‡ßÅ‡¶ü (Pinch) ‡¶ï‡¶∞‡ßÅ‡¶®</div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const scoreElement = document.getElementById('score_board');
        const loadingElement = document.getElementById('loading');

        let score = 0;
        let birds = [];
        let particles = []; // For explosion effect
        let lastShotTime = 0;
        let isShooting = false;
        
        // Hand coordinates
        let aimX = 0;
        let aimY = 0;

        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- BIRD CLASS (Procedural Drawing) ---
        class Bird {
            constructor() {
                this.y = Math.random() * (canvasElement.height * 0.7);
                this.size = 30 + Math.random() * 20;
                this.speed = 2 + Math.random() * 3;
                this.flapSpeed = 0.1 + Math.random() * 0.1;
                this.wingAngle = 0;
                
                // Decide direction (Left to Right OR Right to Left)
                if (Math.random() < 0.5) {
                    this.x = -50;
                    this.vx = this.speed;
                    this.direction = 1; // Facing Right
                } else {
                    this.x = canvasElement.width + 50;
                    this.vx = -this.speed;
                    this.direction = -1; // Facing Left
                }
                this.markedForDeletion = false;
            }

            update() {
                this.x += this.vx;
                this.wingAngle += this.flapSpeed;
                
                // Out of screen check
                if ((this.vx > 0 && this.x > canvasElement.width + 50) || 
                    (this.vx < 0 && this.x < -50)) {
                    this.markedForDeletion = true;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.direction, 1); // Flip based on direction

                // Draw Body
                ctx.fillStyle = "#333";
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size/2, 0, 0, Math.PI*2);
                ctx.fill();

                // Draw Wing (Flapping)
                let wingY = Math.sin(this.wingAngle) * this.size;
                ctx.fillStyle = "#555";
                ctx.beginPath();
                ctx.moveTo(-10, 0);
                ctx.quadraticCurveTo(0, -this.size - wingY, 15, 0);
                ctx.fill();

                // Draw Beak
                ctx.fillStyle = "orange";
                ctx.beginPath();
                ctx.moveTo(this.size - 5, -5);
                ctx.lineTo(this.size + 10, 0);
                ctx.lineTo(this.size - 5, 5);
                ctx.fill();

                // Draw Eye
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(this.size/2, -5, 4, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.size/2 + 2, -5, 2, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
            }
        }

        // --- PARTICLE SYSTEM (Feathers/Explosion) ---
        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 1.0;
                this.color = color;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.05;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // --- SHOOTING LOGIC ---
        function fireShot() {
            // Cooldown check (prevent machine gun)
            let now = performance.now();
            if (now - lastShotTime < 300) return; 
            lastShotTime = now;

            // Visual Muzzle Flash
            canvasCtx.fillStyle = "rgba(255, 255, 0, 0.5)";
            canvasCtx.beginPath();
            canvasCtx.arc(aimX, aimY, 40, 0, Math.PI*2);
            canvasCtx.fill();

            // Collision Detection
            for (let i = 0; i < birds.length; i++) {
                let b = birds[i];
                // Distance between Aim point and Bird center
                let dist = Math.sqrt((aimX - b.x) ** 2 + (aimY - b.y) ** 2);
                
                if (dist < b.size + 20) { // Hit!
                    score += 10;
                    scoreElement.innerText = "Score: " + score;
                    b.markedForDeletion = true;
                    
                    // Spawn particles
                    for(let j=0; j<10; j++) {
                        particles.push(new Particle(b.x, b.y, "#555"));
                        particles.push(new Particle(b.x, b.y, "orange"));
                    }
                }
            }
        }

        // --- MEDIAPIPE HANDLER ---
        function onResults(results) {
            loadingElement.style.display = 'none';
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // Hand Tracking
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Points: 8 = Index Tip, 4 = Thumb Tip
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];

                // Convert to canvas coordinates
                let ix = indexTip.x * canvasElement.width;
                let iy = indexTip.y * canvasElement.height;
                let tx = thumbTip.x * canvasElement.width;
                let ty = thumbTip.y * canvasElement.height;

                // Set Aim Point (Average of Index and Thumb is smoother, or just Index)
                aimX = ix;
                aimY = iy;

                // Draw Crosshair (Gun Sight)
                canvasCtx.strokeStyle = "#00FF00";
                canvasCtx.lineWidth = 3;
                canvasCtx.beginPath();
                canvasCtx.arc(aimX, aimY, 20, 0, Math.PI*2); // Circle
                canvasCtx.moveTo(aimX - 25, aimY); canvasCtx.lineTo(aimX + 25, aimY); // Horizontal Line
                canvasCtx.moveTo(aimX, aimY - 25); canvasCtx.lineTo(aimX, aimY + 25); // Vertical Line
                canvasCtx.stroke();

                // CHECK GESTURE: Pinch (Thumb touching Index)
                // Calculate distance between Index Tip and Thumb Tip
                let distance = Math.sqrt((ix - tx)**2 + (iy - ty)**2);

                // If distance is small (fingers touching), Fire!
                if (distance < 50) { 
                    canvasCtx.strokeStyle = "red"; // Crosshair turns red
                    canvasCtx.stroke();
                    fireShot();
                }
            }

            // Update Game Objects
            // Spawn Birds
            if (Math.random() < 0.02) birds.push(new Bird());

            // Update Birds
            birds = birds.filter(b => !b.markedForDeletion);
            birds.forEach(b => {
                b.update();
                b.draw(canvasCtx);
            });

            // Update Particles
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                p.update();
                p.draw(canvasCtx);
            });

            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 1280, height: 720, facingMode: "user"
        });
        camera.start();

    </script>
</body>
</html>
